

package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	boolean errorDetected;

	Logger log = Logger.getLogger(getClass());


    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }


:}

init with {:
	errorDetected = false;
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null)
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROG, RETURN, CHARCONST, RBRACE, LBRACE, CONST;
terminal EQUAL, PLUSPLUS, MINUSMINUS, DOTCOMMA, READ, LPAREN, RPAREN, PRINT, COMMA;
terminal BOOLCONST, NEW, LSQUARE, RSQUARE, PLUS, MINUS, MUL, DIV, PERCENT;
terminal String IDENT;
terminal Integer NUMBER;

nonterminal DesignatorStatement, NumberInPrint, Minus, Addop, FunctionParameters;
nonterminal MulopFactor, Mulop, ExprList, VarDecl, SquareList, IdentInLine, IdentList;
nonterminal IdentSquareList, FormPars, TypeIdentSquareList, DesignatorListMany, DesignatorList;
nonterminal VarDeclList, MethodDeclList, StatementList, FormalParamDecl;

nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName, Program, MethodDecl, MethodTypeName, Designator, FormParsLst, IdentTypeInLine, ReturnStatement;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type, Term, Factor, Expr, AddopTerm, Statement;

Program ::= (Program) PROG ProgName:p VarDeclList LBRACE MethodDeclList RBRACE;

ProgName ::= (ProgName) IDENT:progName;

VarDeclList ::= (VarDeclarations) VarDeclList VarDecl
			|
			(NoVarDecl) /* epsilon smena */
			;

VarDecl ::= (VarDeclarationArray) Type:varType IDENT:varName SquareList IdentSquareList DOTCOMMA
          | (ConstVarDeclaration) CONST Type:varType IDENT:varName EQUAL Factor DOTCOMMA
          | (VarDeclarationEqual) Type:varType IDENT:varName EQUAL Factor DOTCOMMA
          ;

MethodDeclList ::= (MethodDeclarations) MethodDeclList MethodDecl
				|
				(NoMethodDecl) /* epsilon smena */
				;

MethodDecl ::= (MethodDecl) MethodTypeName LPAREN FormParsLst RPAREN VarDeclList LBRACE StatementList ReturnStatement RBRACE;

ReturnStatement ::= (ReturnStatementOnly) RETURN DOTCOMMA
                  | (ReturnStatementExpr) RETURN Expr:exprName DOTCOMMA
                  | (NoReturnStatement) /* epsilon smena */
                  ;

MethodTypeName ::= (MethodTypeName) Type:retType IDENT:metName;

StatementList ::= (Statements) StatementList Statement
				|
				(NoStmt) /* epsilon smena */
				;

FormParsLst ::= (FormParams) FormParsLst Type:typeName IDENT:identName IdentList
		  | (NoFormParams) /* epsilon smena */
		  ;

IdentList ::= (IdentLists) IdentList IdentTypeInLine
            | (NoIdentLists) /* epsilon smena */
            ;

DesignatorStatement ::= (DesignatorStatementEqual) Designator:dest EQUAL Expr:e
                       | (DesignatorStatementArray) LSQUARE DesignatorList DesignatorListMany RSQUARE EQUAL Designator
                       | (DesignatorStatementPlusPlus) Designator PLUSPLUS
                       | (DesignatorStatementMinusMinus) Designator MINUSMINUS
                       ;

DesignatorListMany ::= (DesignatorListRec) DesignatorListMany COMMA DesignatorList
                     | (NoDesignatorList) /* epsilon smena */
                     ;

DesignatorList ::= (DesignatorListDesignator) Designator
                 | (NoDesignatorListDesignator) /* epsilon smena */
                 ;

Statement ::= (StatementDesignator) DesignatorStatement DOTCOMMA
            |
              error DOTCOMMA:l
              {: parser.report_error("Izvrsen oporavak do ; u liniji " + lleft, null); :}
            | (StatementRead) READ LPAREN Designator RPAREN DOTCOMMA
            | (PrintStmt) PRINT LPAREN Expr NumberInPrint RPAREN DOTCOMMA
            | (FuncCall) Designator:func LPAREN FormParsLst RPAREN DOTCOMMA
            ;

NumberInPrint ::= (NumberInPrintNumber) COMMA NUMBER
                | (NoNumberInPrintNumber) /* epsilon smena */
                ;

Expr ::= (Expression) Minus Term AddopTerm ;

AddopTerm ::= (AddOperationTerminatorRec) AddopTerm:te Addop Term
            | (NoAddOperationTerminator) /* epsilon smena */
            ;

Minus ::= (MinusExpression) MINUS
        | (NoMinusExpression) /* epsilon smena */
        ;

Term ::= (Terminator) Factor:t MulopFactor ;

MulopFactor ::= (MulopFactorRec) MulopFactor Mulop Factor
              | (NoMulopFactor) /* epsilon smena */
              ;

Factor ::= (FactorNum) NUMBER
         | (FactorChar) CHARCONST
         | (FactorExpr) LPAREN Expr RPAREN
         | (FactorBool) BOOLCONST
         | (FactorNewExpr) NEW Type LSQUARE Expr RSQUARE
         | (FactorDes) Designator:d
         | (FactorNewTypeExpr) NEW Type LSQUARE Expr RSQUARE LSQUARE Expr RSQUARE
         ;

Designator ::= (DesignatorExpression) IDENT:name ExprList ;

ExprList ::= (ExprListExpr) LSQUARE Expr RSQUARE
           | (NoExprListExpr) /* epsilon smena */
           ;

Addop ::= (AddOperationPlus) PLUS
        | (AddOperationMinus) MINUS
        ;

Mulop ::= (MulOperationMul) MUL
        | (MulOperationDiv) DIV
        | (MulOperationPercent) PERCENT
        ;

IdentSquareList ::= (IdentSquareListRec) IdentSquareList IdentInLine SquareList
                  | (NoIdentSquareList) /* epsilon smena */
                  ;

IdentInLine ::= (IdentInLine) COMMA IDENT:identName;

IdentTypeInLine ::= (IdentTypeInLine) COMMA Type:typeName IDENT:identName;

FormPars ::= (FormParsMatrix) Type IDENT SquareList TypeIdentSquareList DOTCOMMA;

TypeIdentSquareList ::= (TypeIdentSquareListRec) TypeIdentSquareList COMMA Type:typeName IDENT:identName SquareList
                  | (NoTypeIdentSquareList) /* epsilon smena */
                  ;

SquareList ::= (SquareListOutside) LSQUARE RSQUARE LSQUARE RSQUARE
             | (SquareListOutsideOne) LSQUARE RSQUARE
             | (NoSquareListOutside) /* epsilon smena */
             ;

Type ::= (TypeIdent) IDENT:typeName ;




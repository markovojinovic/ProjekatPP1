

package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	Logger log = Logger.getLogger(getClass());


    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }


:}


scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null)
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROG, RETURN, VOID, CHARCONST, RBRACE, LBRACE, CONST;
terminal EQUAL, PLUSPLUS, MINUSMINUS, DOTCOMMA, READ, LPAREN, RPAREN, PRINT, COMMA, NUMBER;
terminal BOOLCONST, NEW, LSQUARE, RSQUARE, PLUS, MINUS, MUL, DIV, PERCENT, IDENT ;

nonterminal DesignatorStatement DesignatorStatement;
nonterminal Designator Designator;
nonterminal Expr Expr;
nonterminal NumberInPrint NumberInPrint;
nonterminal Minus Minus;
nonterminal Term Term;
nonterminal AddopTerm AddopTerm;
nonterminal Addop Addop;
nonterminal  Factor Factor;
nonterminal MulopFactor MulopFactor;
nonterminal Mulop Mulop;
nonterminal Type Type;
nonterminal ExprList ExprList;
nonterminal VarDecl VarDecl;
nonterminal SquareList SquareList;
nonterminal FunctionType FunctionType;
nonterminal IdentSquareList IdentSquareList;
nonterminal FormPars FormPars;
nonterminal TypeIdentSquareList TypeIdentSquareList;
nonterminal DesignatorListMany DesignatorListMany;
nonterminal DesignatorList DesignatorList;
nonterminal Statement Statement;
nonterminal VarDeclList VarDeclList;
nonterminal MethodDeclList MethodDeclList;
nonterminal Program Program;
nonterminal MethodDecl MethodDecl;
nonterminal StatementList StatementList;
nonterminal FormalParamDecl FormalParamDecl;
nonterminal FormParsLst FormParsLst;

Program ::= (Program) PROG IDENT VarDeclList:V1 LBRACE MethodDeclList:M2 RBRACE {: RESULT=new Program(V1, M2); RESULT.setLine(V1left); :};

VarDeclList ::= (VarDeclarations) VarDeclList:V1 VarDecl:V2 {: RESULT=new VarDeclarations(V1, V2); RESULT.setLine(V1left); :}
			|
			(NoVarDecl) {: RESULT=new NoVarDecl(); :} /* epsilon smena */
			;

VarDecl ::= (VarDeclarationArray) Type:T1 IDENT SquareList:S2 IdentSquareList:I3 DOTCOMMA {: RESULT=new VarDeclarationArray(T1, S2, I3); RESULT.setLine(T1left); :}
          | (ConstVarDeclaration) CONST Type:T1 IDENT EQUAL Factor:F2 DOTCOMMA {: RESULT=new ConstVarDeclaration(T1, F2); RESULT.setLine(T1left); :}
          | (VarDeclarationEqual) Type:T1 IDENT EQUAL Factor:F2 DOTCOMMA {: RESULT=new VarDeclarationEqual(T1, F2); RESULT.setLine(T1left); :}
          ;

MethodDeclList ::= (MethodDeclarations) MethodDeclList:M1 MethodDecl:M2 {: RESULT=new MethodDeclarations(M1, M2); RESULT.setLine(M1left); :}
				|
				(NoMethodDecl) {: RESULT=new NoMethodDecl(); :} /* epsilon smena */
				;

MethodDecl ::= (MethodDecl) FunctionType:F1 IDENT LPAREN FormParsLst:F2 RPAREN VarDeclList:V3 LBRACE StatementList:S4 RBRACE {: RESULT=new MethodDecl(F1, F2, V3, S4); RESULT.setLine(F1left); :};

FunctionType ::= (FType) Type:T1 {: RESULT=new FType(T1); RESULT.setLine(T1left); :} | VOID {: RESULT=new FunctionTypeDerived1(); :} ;

StatementList ::= (Statements) StatementList:S1 Statement:S2 {: RESULT=new Statements(S1, S2); RESULT.setLine(S1left); :}
				|
				(NoStmt) {: RESULT=new NoStmt(); :} /* epsilon smena */
				;

FormParsLst ::= (FormParams) FormPars:F1 {: RESULT=new FormParams(F1); RESULT.setLine(F1left); :}
		  |
		  (NoFormParam) {: RESULT=new NoFormParam(); :} /* epsilon */
		  ;

DesignatorStatement ::= (DesignatorStatementEqual) Designator:D1 EQUAL Expr:E2 {: RESULT=new DesignatorStatementEqual(D1, E2); RESULT.setLine(D1left); :}
                       | (DesignatorStatementArray) LSQUARE DesignatorList:D1 DesignatorListMany:D2 RSQUARE EQUAL Designator:D3 {: RESULT=new DesignatorStatementArray(D1, D2, D3); RESULT.setLine(D1left); :}
                       | (DesignatorStatementPlusPlus) Designator:D1 PLUSPLUS {: RESULT=new DesignatorStatementPlusPlus(D1); RESULT.setLine(D1left); :}
                       | (DesignatorStatementMinusMinus) Designator:D1 MINUSMINUS {: RESULT=new DesignatorStatementMinusMinus(D1); RESULT.setLine(D1left); :}
                       ;

DesignatorListMany ::= (DesignatorListRec) DesignatorListMany:D1 COMMA DesignatorList:D2 {: RESULT=new DesignatorListRec(D1, D2); RESULT.setLine(D1left); :}
                     | (NoDesignatorList) {: RESULT=new NoDesignatorList(); :} /* epsilon smena */
                     ;

DesignatorList ::= (DesignatorListDesignator) Designator:D1 {: RESULT=new DesignatorListDesignator(D1); RESULT.setLine(D1left); :}
                 | (NoDesignatorListDesignator) {: RESULT=new NoDesignatorListDesignator(); :} /* epsilon smena */
                 ;

Statement ::= (StatementDesignator) DesignatorStatement:D1 DOTCOMMA {: RESULT=new StatementDesignator(D1); RESULT.setLine(D1left); :}
            |
              error DOTCOMMA:l
              {: parser.report_error("Izvrsen oporavak do ; u liniji " + lleft, null); :} {: RESULT=new StatementDerived1(); :}
            | (StatementRead) READ LPAREN Designator:D1 RPAREN DOTCOMMA {: RESULT=new StatementRead(D1); RESULT.setLine(D1left); :}
            | (PrintStmt) PRINT LPAREN Expr:E1 NumberInPrint:N2 RPAREN DOTCOMMA {: RESULT=new PrintStmt(E1, N2); RESULT.setLine(E1left); :}
            ;

NumberInPrint ::= (NumberInPrintNumber) COMMA NUMBER {: RESULT=new NumberInPrintNumber(); :}
                | (NoNumberInPrintNumber) {: RESULT=new NoNumberInPrintNumber(); :} /* epsilon smena */
                ;

Expr ::= (Expression) Minus:M1 Term:T2 AddopTerm:A3 {: RESULT=new Expression(M1, T2, A3); RESULT.setLine(M1left); :} ;

AddopTerm ::= (AddOperationTerminatorRec) AddopTerm:A1 Addop:A2 Term:T3 {: RESULT=new AddOperationTerminatorRec(A1, A2, T3); RESULT.setLine(A1left); :}
            | (NoAddOperationTerminator) {: RESULT=new NoAddOperationTerminator(); :} /* epsilon smena */
            ;

Minus ::= (MinusExpression) MINUS {: RESULT=new MinusExpression(); :}
        | (NoMinusExpression) {: RESULT=new NoMinusExpression(); :} /* epsilon smena */
        ;

Term ::= (Terminator) Factor:F1 MulopFactor:M2 {: RESULT=new Terminator(F1, M2); RESULT.setLine(F1left); :} ;

MulopFactor ::= (MulopFactorRec) MulopFactor:M1 Mulop:M2 Factor:F3 {: RESULT=new MulopFactorRec(M1, M2, F3); RESULT.setLine(M1left); :}
              | (NoMulopFactor) {: RESULT=new NoMulopFactor(); :} /* epsilon smena */
              ;

Factor ::= (FactorNum) NUMBER {: RESULT=new FactorNum(); :}
         | (FactorChar) CHARCONST {: RESULT=new FactorChar(); :}
         | (FactorExpr) LPAREN Expr:E1 RPAREN {: RESULT=new FactorExpr(E1); RESULT.setLine(E1left); :}
         | (FactorBool) BOOLCONST {: RESULT=new FactorBool(); :}
         | (FactorNewExpr) NEW Type:T1 LSQUARE Expr:E2 RSQUARE {: RESULT=new FactorNewExpr(T1, E2); RESULT.setLine(T1left); :}
         | (FactorDes) Designator:D1 {: RESULT=new FactorDes(D1); RESULT.setLine(D1left); :}
         | (FactorNewTypeExpr) NEW Type:T1 LSQUARE Expr:E2 RSQUARE LSQUARE Expr:E3 RSQUARE {: RESULT=new FactorNewTypeExpr(T1, E2, E3); RESULT.setLine(T1left); :}
         ;

Designator ::= (DesignatorExpression) IDENT ExprList:E1 {: RESULT=new DesignatorExpression(E1); RESULT.setLine(E1left); :} ;

ExprList ::= (ExprListExpr) LSQUARE Expr:E1 RSQUARE {: RESULT=new ExprListExpr(E1); RESULT.setLine(E1left); :}
           | (NoExprListExpr) {: RESULT=new NoExprListExpr(); :} /* epsilon smena */
           ;

Addop ::= (AddOperationPlus) PLUS {: RESULT=new AddOperationPlus(); :}
        | (AddOperationMinus) MINUS {: RESULT=new AddOperationMinus(); :}
        ;

Mulop ::= (MulOperationMul) MUL {: RESULT=new MulOperationMul(); :}
        | (MulOperationDiv) DIV {: RESULT=new MulOperationDiv(); :}
        | (MulOperationPercent) PERCENT {: RESULT=new MulOperationPercent(); :}
        ;

IdentSquareList ::= (IdentSquareListRec) IdentSquareList:I1 COMMA IDENT SquareList:S2 {: RESULT=new IdentSquareListRec(I1, S2); RESULT.setLine(I1left); :}
                  | (NoIdentSquareList) {: RESULT=new NoIdentSquareList(); :} /* epsilon smena */
                  ;

FormPars ::= (FormParsMatrix) Type:T1 IDENT SquareList:S2 TypeIdentSquareList:T3 DOTCOMMA {: RESULT=new FormParsMatrix(T1, S2, T3); RESULT.setLine(T1left); :} ;

TypeIdentSquareList ::= (TypeIdentSquareListRec) TypeIdentSquareList:T1 COMMA Type:T2 IDENT SquareList:S3 {: RESULT=new TypeIdentSquareListRec(T1, T2, S3); RESULT.setLine(T1left); :}
                  | (NoTypeIdentSquareList) {: RESULT=new NoTypeIdentSquareList(); :} /* epsilon smena */
                  ;

SquareList ::= (SquareListOutside) LSQUARE RSQUARE LSQUARE RSQUARE {: RESULT=new SquareListOutside(); :}
             | (SquareListOutsideOne) LSQUARE RSQUARE {: RESULT=new SquareListOutsideOne(); :}
             | (NoSquareListOutside) {: RESULT=new NoSquareListOutside(); :} /* epsilon smena */
             ;

Type ::= (TypeIdent) IDENT {: RESULT=new TypeIdent(); :} ;



